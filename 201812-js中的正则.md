### js中的正则

#### 正则表达式的定义
正则表达式是用来处理字符串的匹配模式，用来匹配字符或者匹配位置。模糊匹配是正则强大的主要原因。

#### 基础匹配
##### 匹配一组字符
当需要的匹配的字符是一组字符中的一个时，可以用字符组匹配，例如：

```
[abc]
[123]
```
可以简写成区间形式：

```
[a-c]
[1-3]
```
取非类型的字符组：
```
[^abc]  // 不是 abc 中的任意一个
[^123]  // 不是 123 中的任意一个
```

##### 匹配一类字符
用一个字符来匹配某一类的字符，常用的如下：

元字符 | 等价字符组 | 含义  
---|---|--- 
. |  [^\n\r\u2028\u2029] | 换行符、回车符、行分隔符和段分隔符以外的任意字符
\d | [0-9] | 数字
\D | [^0-9]| 非数字
\w | [0-9a-zA-Z_] | 数字、大小写字母和下划线 
\W | [^0-9a-zA-Z_] | 非单词字符
\s | [ \t\v\n\r\f] | 空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符
\S | [^ \t\v\n\r\f] | 非空白符

##### 匹配边界
元字符 | 含义
---|---
^ | 匹配开始
$ | 匹配结束
\b | 匹配单词边界
\B | 匹配非单词边界

##### 匹配的次数
量词默认按贪婪模式匹配，也就是尽可能多的匹配，即使已经匹配到满足条件的内容，仍继续匹配力求最大匹配长度。  
量词后面加上 '?'，可令表达式用惰性模式匹配，就是尽可能少的匹配，一旦满足了最小匹配次数就立刻停止。
量词 | 含义 | 惰性模式
---|---|---
{m,n} | 匹配 m 到 n 次 | {m,n}? | 匹配 m 到 n 次，尽可能少的
{m,} | 至少匹配 m 次 | {m,}?
{m} | 匹配刚好 m 次 | (无)
? | 相当于{0,1}，匹配0次或1次 | ??
* | 相当于{0,n}，匹配至少0次 | *?
+ | 相当于{1,n}，匹配至少1次 | +?

##### 匹配多种可能性
可用多选分支表达式：

```
(p1|p2|p3)
```
这里 p1、p2 和 p3 是子模式。分支表达式是惰性的。

#### 修饰符
符号 | 全称 | 含义
---|---|---
g | global | 全局匹配，找到所有的。默认匹配到第一个满足条件的内容就停止了
i | ignore case | 忽略大小写
m | multiline | 多行匹配，只影响 ^ 和 $，二者匹配行开头和行结尾
y | sticky | y 修饰符也是全局搜索，它要求匹配必须从上次匹配剩余的第一个位置开始
u | unicode | 用来处理大于 \uFFFF 的 Unicode 字符。也就是四个字节的 UTF-16 编码
s | dot all | 用 . 匹配任意字符，包括换行、回车、行分隔符、段分隔符

#### 分组与引用
将子表达式用 () 包起来，意味着匹配并捕获结果，也就是分组。  
() 可以嵌套，组的序号依 ( 出现的顺序而定。  
分组后的表达式，可以引用匹配结果。

##### 在表达式中引用
使用 \n 可以直接在正则表达式中引用到前面匹配到的结果。  
其中 n 表示分组的序号，从1开始。  
假设需要匹配月和日相同的日期，如下：

```
var reg = /(\d{4})-(\d{2})-\2/;
reg.test('2018-04-04');  // true
reg.test('2018-04-05');  // false
```
匹配结果也可以用 RegExp.$n 访问到，同样的 n 指分组的序号。  
接上面的例子：

```
reg.test('2018-04-04');
RegExp.$1  // '2018'
RegExp.$2  // '04'
```
如果想在 replace 中访问到分组结果，直接用 '$n' 即可。
以姓名反序为例：

```
'Amy Peng'.replace(/(\w+)\s(\w+)/, '$2 $1');  // 'Peng Amy'
```
除了使用序号访问分组，也可以给分组起名，格式如下：

```
/(?<year>\d{4})-(?<month>\d{2})-\k<month>/.test('2018-04-04');  // true
```

#### 零宽断言
零宽意味着匹配的是位置。由于处在分组中，也会被捕获，但因为是位置，引用到的都是 '' 空串。  
positive lookahead | negative lookahead | positive lookbehind | negative lookbehind
---|---|---|---
(?=pattern) | (?!pattern) | (?<=pattern) | (?<!pattern)
匹配 pattern 前的那个位置 | 匹配非 pattern 前的那个位置 | 匹配 pattern 后的那个位置 | 匹配非 pattern 后的那个位置
具体例子：

```
'hello'.replace(/(?=l)/g, '#');  // 'he#l#lo'
'hello'.replace(/(?!l)/g, '#');  // '#h#ell#o#'
'hello'.replace(/(?<=l)/g, '#');  // "hel#l#o"
'hello'.replace(/(?<!l)/g, '#');  // "#h#e#llo#"
```
需要注意的是，ES6 开始才支持 (?<=pattern) 和 (?<!pattern)

#### 非捕获分组
如果不需要引用，可使用非捕获分组，这样该分组的匹配内容不会出现在匹配结果中。  
语法为 (?:pattern)，举例如下：

```
'2018-04-04'.match(/(?:\d{4})-(\d{2})-\1/);  // ["2018-04-04", "04", index: 0, input: "2018-04-04", groups: undefined]
```
#### 转义
理论上讲，匹配元字符这个字符本身、以及有特殊含义的字符时，都需要用反斜线（\）转义，包括：

```
^  $  .  *  +  ?  |  \  /  (  )  [  ]  {  }  =  !  :  - 
```
实际使用中，某个字符是否需要转义还是看情况。  
还是日期匹配的例子：

```
/\d{4}-\d{2}-\d{2}/.test('2018-04-16');
```
这里面的 '-' 就不需要转义。

#### 常用正则表达式
手机号

```
/^1\d{10}$/
```
QQ
```
/^[1-9]\d{4,10}$/
```
数字（考虑带符号、含小数点）
```
/^[-+]?(?:\d*|(?=\d))(\.\d*)?$/
```
Email
```
/^[\da-z](\w|-|\.)*@(\w|-|\.)+$/
```
URL
```
/^http[s]*\:\/\/.+$/
```
ipv4
```
/^(\d{1,2}|1\d{2}|2[0-5][0-5])(\.(\d{1,2}|1\d{2}|2[0-5][0-5])){3}$/
```
18位身份证（不考虑闰年）
```
/^(\d){6}(19|20)(\d){2}(((0[13578]|10|12)31)|((0[13456789]|10|11|12)30)|(0\d|10|11|12)([01]\d|2[0-9]))(\d){3}(\d|X|x)$/
```


#### 参考资料
> https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp  
> https://zhuanlan.zhihu.com/p/29707385  
> http://es6.ruanyifeng.com/#docs/regex
